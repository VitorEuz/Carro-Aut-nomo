import cv2
import numpy as np
from ultralytics import YOLO

# Carregar o modelo YOLOv8 personalizado (.pt) com o logging desativado
model = YOLO("C:/Users/thiag/Emilia/V3/yolov8n.pt")  # Substitua pelo caminho do seu arquivo .pt

# Desativar os logs do YOLOv8
model.overrides['verbose'] = False  # Desativa mensagens do modelo

# Função para calcular a distância
def calculate_distance(known_width, focal_length, pixel_width):
    return (known_width * focal_length) / pixel_width

# Definir parâmetros conhecidos
KNOWN_WIDTHS = {"person": 0.5, "stop sign": 0.75, "traffic light": 0.4}  # Largura média de pessoas e objetos em metros
FOCAL_LENGTH = 600  # Valor hipotético, precisa ser ajustado dependendo da câmera

# Função para verificar a cor dominante
def get_dominant_color(image, region):
    # Converter a região para o espaço de cores HSV
    hsv = cv2.cvtColor(region, cv2.COLOR_BGR2HSV)

    # Definir faixas de cor para vermelho e verde no espaço HSV
    red_lower1 = np.array([0, 100, 100])
    red_upper1 = np.array([10, 255, 255])
    red_lower2 = np.array([160, 100, 100])
    red_upper2 = np.array([180, 255, 255])

    green_lower = np.array([40, 50, 50])
    green_upper = np.array([80, 255, 255])

    # Criar máscaras para as cores
    red_mask1 = cv2.inRange(hsv, red_lower1, red_upper1)
    red_mask2 = cv2.inRange(hsv, red_lower2, red_upper2)
    red_mask = cv2.bitwise_or(red_mask1, red_mask2)

    green_mask = cv2.inRange(hsv, green_lower, green_upper)

    # Contar os pixels vermelhos e verdes
    red_count = cv2.countNonZero(red_mask)
    green_count = cv2.countNonZero(green_mask)

    # Determinar a cor dominante
    if red_count > green_count:
        return "Red"
    elif green_count > red_count:
        return "Green"
    else:
        return "Unknown"

# Função para verificar se um ponto está abaixo da linha
def is_below_line(x1, y1, x2, y2, px, py):
    # Fórmula para verificar se o ponto (px, py) está abaixo da linha definida por (x1, y1) e (x2, y2)
    return (py - y1) * (x2 - x1) > (y2 - y1) * (px - x1)

# Definir os pontos da linha vermelha (pode ajustar conforme necessário)
line_start = (100, 300)  # Ponto inicial da linha
line_end = (500, 300)    # Ponto final da linha

# Captura de vídeo
cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)

while cap.isOpened():
    ret, frame = cap.read()

    # Desenhar a linha vermelha na imagem
    cv2.line(frame, line_start, line_end, (0, 0, 255), 2)

    # Realizar a detecção usando o modelo YOLOv8
    results = model(frame)

    for result in results:
        boxes = result.boxes
        for box in boxes:
            class_id = int(box.cls)
            label = model.names[class_id]
            if label in KNOWN_WIDTHS:  # Verifica se a classe é uma das desejadas
                # Obter coordenadas da caixa delimitadora
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                w = x2 - x1
                h = y2 - y1

                # Calcular a distância
                object_width = KNOWN_WIDTHS[label]
                distance = calculate_distance(object_width, FOCAL_LENGTH, w)

                # Desenhar caixa e a distância
                color = (0, 255, 0)
                cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                cv2.putText(frame, f"{label}: {distance:.2f}m", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

                # Verificar se é um semáforo e determinar a cor da luz
                if label == "traffic light":
                    region_upper = frame[y1:int(y1 + h // 3), x1:x2]  # Parte superior (vermelho)
                    region_lower = frame[int(y1 + 2 * h // 3):y2, x1:x2]  # Parte inferior (verde)
                    upper_color = get_dominant_color(frame, region_upper)
                    lower_color = get_dominant_color(frame, region_lower)
                    if upper_color == "Red":
                        light_status = "Red light"
                    elif lower_color == "Green":
                        light_status = "Green light"
                    else:
                        light_status = "Unknown light"
                    cv2.putText(frame, light_status, (x1, y2 + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)
                    if light_status == "Red light" and distance < 2:
                        print("PARE!")

                # Verificar se uma pessoa está abaixo da linha e a menos de 2 metros
                if label == "person" and distance < 2:
                    person_center_x = (x1 + x2) // 2
                    person_center_y = y2  # Considerando a parte inferior da pessoa
                    if is_below_line(*line_start, *line_end, person_center_x, person_center_y):
                        print("PARE!")

                # Verificar se uma placa de pare está a menos de 2 metros
                if label == "stop sign" and distance < 2:
                    print("PARE!")

    # Exibir a imagem
    cv2.imshow("Image", frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
